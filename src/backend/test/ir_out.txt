@last_char = dso_local global i32 32
@num = dso_local global i32 0
@other = dso_local global i32 0
@cur_token = dso_local global i32 0

declare i32 @getint()
declare float @getfloat()
declare i32 @getarray(i32*)
declare i32 @getfarray(float*)
declare i32 @getch()
declare void @putint(i32)
declare void @putch(i32)
declare void @putfloat(float)
declare void @putarray(i32,i32*)
declare void @putfarray(i32,float*)
declare void @memset(i32*,i32,i32)
declare void @starttime()
declare void @stoptime()

define dso_local i32 @next_char(){
entry:     
  %0 = call i32 @getch()     ; call getch()
  store i32 %0, i32* @last_char     ; last_char=getch()
  %1 = load i32, i32* @last_char     
  ret i32 %1     
}

define dso_local i32 @is_space(i32 %0){
entry:     
  %1 = alloca i32     ; i32 c
  store i32 %0, i32* %1     
  %2 = load i32, i32* %1     
  %3= icmp eq i32 %2, 32     ; c==32
  br i1 %3, label %7, label %4     

4:     
  %5 = load i32, i32* %1     
  %6= icmp eq i32 %5, 10     ; c==32 || c==10
  br i1 %6, label %7, label %8     ; judge c==32||c==10

7:     ; if Stmt
  ret i32 1     

8:     ; else Stmt
  ret i32 0     

9:     
  ret i32 0     
}

define dso_local i32 @is_num(i32 %0){
entry:     
  %1 = alloca i32     ; i32 c
  store i32 %0, i32* %1     
  %2 = load i32, i32* %1     
  %3= icmp sge i32 %2, 48     ; c>=48
  br i1 %3, label %4, label %8     

4:     
  %5 = load i32, i32* %1     
  %6= icmp sle i32 %5, 57     ; c>=48 && c<=57
  br i1 %6, label %7, label %8     ; judge c>=48&&c<=57

7:     ; if Stmt
  ret i32 1     

8:     ; else Stmt
  ret i32 0     

9:     
  ret i32 0     
}

define dso_local i32 @next_token(){
entry:     
  br label %0     

0:     ; judge is_space(last_char)
  %1 = load i32, i32* @last_char     
  %2 = call i32 @is_space(i32 %1)     ; call is_space(last_char)
  %3= icmp ne i32 %2, 0     
  br i1 %3, label %4, label %6     

4:     ; while Stmt
  %5 = call i32 @next_char()     ; call next_char()
  br label %0     

6:     ; exit while
  %7 = load i32, i32* @last_char     
  %8 = call i32 @is_num(i32 %7)     ; call is_num(last_char)
  %9= icmp ne i32 %8, 0     
  br i1 %9, label %10, label %24     ; judge is_num(last_char)

10:     ; if Stmt
  %11 = load i32, i32* @last_char     
  %12 = sub i32 %11, 48     ; last_char-48
  store i32 %12, i32* @num     ; num=last_char-48
  br label %13     

13:     ; judge is_num(next_char())
  %14 = call i32 @next_char()     ; call next_char()
  %15 = call i32 @is_num(i32 %14)     ; call is_num(next_char())
  %16= icmp ne i32 %15, 0     
  br i1 %16, label %17, label %23     

17:     ; while Stmt
  %18 = load i32, i32* @num     
  %19 = mul i32 %18, 10     ; num*10
  %20 = load i32, i32* @last_char     
  %21 = add i32 %19, %20     ; num*10+last_char
  %22 = sub i32 %21, 48     ; num*10+last_char-48
  store i32 %22, i32* @num     ; num=num*10+last_char-48
  br label %13     

23:     ; exit while
  store i32 0, i32* @cur_token     ; cur_token=TOKEN_NUM
  br label %27     

24:     ; else Stmt
  %25 = load i32, i32* @last_char     
  store i32 %25, i32* @other     ; other=last_char
  %26 = call i32 @next_char()     ; call next_char()
  store i32 1, i32* @cur_token     ; cur_token=TOKEN_OTHER
  br label %27     

27:     
  %28 = load i32, i32* @cur_token     
  ret i32 %28     
}

define dso_local i32 @panic(){
entry:     
  call void @putch(i32 112)     ; call putch(112)
  call void @putch(i32 97)     ; call putch(97)
  call void @putch(i32 110)     ; call putch(110)
  call void @putch(i32 105)     ; call putch(105)
  call void @putch(i32 99)     ; call putch(99)
  call void @putch(i32 33)     ; call putch(33)
  call void @putch(i32 10)     ; call putch(10)
  ret i32 -1     
}

define dso_local i32 @get_op_prec(i32 %0){
entry:     
  %1 = alloca i32     ; i32 op
  store i32 %0, i32* %1     
  %2 = load i32, i32* %1     
  %3= icmp eq i32 %2, 43     ; op==43
  br i1 %3, label %7, label %4     

4:     
  %5 = load i32, i32* %1     
  %6= icmp eq i32 %5, 45     ; op==43 || op==45
  br i1 %6, label %7, label %8     ; judge op==43||op==45

7:     ; if Stmt
  ret i32 10     

8:     
  %9 = load i32, i32* %1     
  %10= icmp eq i32 %9, 42     ; op==42
  br i1 %10, label %17, label %11     

11:     
  %12 = load i32, i32* %1     
  %13= icmp eq i32 %12, 47     ; op==42 || op==47
  br i1 %13, label %17, label %14     

14:     
  %15 = load i32, i32* %1     
  %16= icmp eq i32 %15, 37     ; op==42 || op==47 || op==37
  br i1 %16, label %17, label %18     ; judge op==42||op==47||op==37

17:     ; if Stmt
  ret i32 20     

18:     
  ret i32 0     
}

define dso_local void @stack_push(i32* %0,i32 %1){
entry:     
  %2 = alloca i32     ; i32 v
  %3 = alloca i32*     ; i32* s
  store i32* %0, i32** %3     
  store i32 %1, i32* %2     
  %4 = load i32*, i32** %3     
  %5= getelementptr i32,i32* %4 , i32 0     
  %6 = load i32*, i32** %3     
  %7= getelementptr i32,i32* %6 , i32 0     
  %8 = load i32, i32* %7     
  %9 = add i32 %8, 1     ; s[0]+1
  store i32 %9, i32* %5     ; s[0]=s[0]+1
  %10 = load i32*, i32** %3     
  %11 = load i32*, i32** %3     
  %12= getelementptr i32,i32* %11 , i32 0     
  %13 = load i32, i32* %12     
  %14= getelementptr i32,i32* %10 , i32 %13     
  %15 = load i32, i32* %2     
  store i32 %15, i32* %14     ; s[s[0]]=v
  ret void     
}

define dso_local i32 @stack_pop(i32* %0){
entry:     
  %1 = alloca i32     ; i32 last=s[s[0]]
  %2 = alloca i32*     ; i32* s
  store i32* %0, i32** %2     
  %3 = load i32*, i32** %2     
  %4 = load i32*, i32** %2     
  %5= getelementptr i32,i32* %4 , i32 0     
  %6 = load i32, i32* %5     
  %7= getelementptr i32,i32* %3 , i32 %6     
  %8 = load i32, i32* %7     
  store i32 %8, i32* %1     ; last= = load i32, i32* 
  %9 = load i32*, i32** %2     
  %10= getelementptr i32,i32* %9 , i32 0     
  %11 = load i32*, i32** %2     
  %12= getelementptr i32,i32* %11 , i32 0     
  %13 = load i32, i32* %12     
  %14 = sub i32 %13, 1     ; s[0]-1
  store i32 %14, i32* %10     ; s[0]=s[0]-1
  %15 = load i32, i32* %1     
  ret i32 %15     
}

define dso_local i32 @stack_peek(i32* %0){
entry:     
  %1 = alloca i32*     ; i32* s
  store i32* %0, i32** %1     
  %2 = load i32*, i32** %1     
  %3 = load i32*, i32** %1     
  %4= getelementptr i32,i32* %3 , i32 0     
  %5 = load i32, i32* %4     
  %6= getelementptr i32,i32* %2 , i32 %5     
  %7 = load i32, i32* %6     
  ret i32 %7     
}

define dso_local i32 @stack_size(i32* %0){
entry:     
  %1 = alloca i32*     ; i32* s
  store i32* %0, i32** %1     
  %2 = load i32*, i32** %1     
  %3= getelementptr i32,i32* %2 , i32 0     
  %4 = load i32, i32* %3     
  ret i32 %4     
}

define dso_local i32 @eval_op(i32 %0,i32 %1,i32 %2){
entry:     
  %3 = alloca i32     ; i32 rhs
  %4 = alloca i32     ; i32 lhs
  %5 = alloca i32     ; i32 op
  store i32 %0, i32* %5     
  store i32 %1, i32* %4     
  store i32 %2, i32* %3     
  %6 = load i32, i32* %5     
  %7= icmp eq i32 %6, 43     ; op==43
  br i1 %7, label %8, label %12     ; judge op==43

8:     ; if Stmt
  %9 = load i32, i32* %4     
  %10 = load i32, i32* %3     
  %11 = add i32 %9, %10     ; lhs+rhs
  ret i32 %11     

12:     
  %13 = load i32, i32* %5     
  %14= icmp eq i32 %13, 45     ; op==45
  br i1 %14, label %15, label %19     ; judge op==45

15:     ; if Stmt
  %16 = load i32, i32* %4     
  %17 = load i32, i32* %3     
  %18 = sub i32 %16, %17     ; lhs-rhs
  ret i32 %18     

19:     
  %20 = load i32, i32* %5     
  %21= icmp eq i32 %20, 42     ; op==42
  br i1 %21, label %22, label %26     ; judge op==42

22:     ; if Stmt
  %23 = load i32, i32* %4     
  %24 = load i32, i32* %3     
  %25 = mul i32 %23, %24     ; lhs*rhs
  ret i32 %25     

26:     
  %27 = load i32, i32* %5     
  %28= icmp eq i32 %27, 47     ; op==47
  br i1 %28, label %29, label %33     ; judge op==47

29:     ; if Stmt
  %30 = load i32, i32* %4     
  %31 = load i32, i32* %3     
  %32 = sdiv i32 %30, %31     ; lhs/rhs
  ret i32 %32     

33:     
  %34 = load i32, i32* %5     
  %35= icmp eq i32 %34, 37     ; op==37
  br i1 %35, label %36, label %40     ; judge op==37

36:     ; if Stmt
  %37 = load i32, i32* %4     
  %38 = load i32, i32* %3     
  %39 = srem i32 %37, %38     ; lhs%rhs
  ret i32 %39     

40:     
  ret i32 0     
}

define dso_local i32 @eval(){
entry:     
  %0 = alloca i32     ; i32 lhs=stack_pop(oprs)
  %1 = alloca i32     ; i32 rhs=stack_pop(oprs)
  %2 = alloca i32     ; i32 cur_op=stack_pop(ops)
  %3 = alloca i32     ; i32 lhs=stack_pop(oprs)
  %4 = alloca i32     ; i32 rhs=stack_pop(oprs)
  %5 = alloca i32     ; i32 cur_op=stack_pop(ops)
  %6 = alloca i32     ; i32 op=other
  %7 = alloca [256 x i32]     ; i32 ops[256]={}
  %8 = alloca [256 x i32]     ; i32 oprs[256]={}
  %9= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  call void @memset(i32* %9,i32 0,i32 1024)     ; oprs
  %10= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0     
  call void @memset(i32* %10,i32 0,i32 1024)     ; ops
  %11 = load i32, i32* @cur_token     
  %12= icmp ne i32 %11, 0     ; cur_token!=TOKEN_NUM
  br i1 %12, label %13, label %15     ; judge cur_token!=TOKEN_NUM

13:     ; if Stmt
  %14 = call i32 @panic()     ; call panic()
  ret i32 %14     

15:     
  %16= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  %17 = load i32, i32* @num     
  call void @stack_push(i32* %16,i32 %17)     ; call stack_push(oprs,num)
  %18 = call i32 @next_token()     ; call next_token()
  br label %19     

19:     ; judge cur_token==TOKEN_OTHER
  %20 = load i32, i32* @cur_token     
  %21= icmp eq i32 %20, 1     ; cur_token==TOKEN_OTHER
  br i1 %21, label %22, label %64     

22:     ; while Stmt
  %23 = load i32, i32* @other     
  store i32 %23, i32* %6     ; op= = load i32, i32* @other
  %24 = load i32, i32* %6     
  %25 = call i32 @get_op_prec(i32 %24)     ; call get_op_prec(op)
  %26= icmp eq i32 %25, 0     ; !get_op_prec(op)
  br i1 %26, label %27, label %28     ; judge !get_op_prec(op)

27:     ; if Stmt
  br label %64     

28:     
  %29 = call i32 @next_token()     ; call next_token()
  br label %30     

30:     ; judge stack_size(ops)&&get_op_prec(stack_peek(ops))>=get_op_prec(op)
  %31= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0     
  %32 = call i32 @stack_size(i32* %31)     ; call stack_size(ops)
  %33= icmp ne i32 %32, 0     
  br i1 %33, label %34, label %53     

34:     
  %35= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0     
  %36 = call i32 @stack_peek(i32* %35)     ; call stack_peek(ops)
  %37 = call i32 @get_op_prec(i32 %36)     ; call get_op_prec(stack_peek(ops))
  %38 = load i32, i32* %6     
  %39 = call i32 @get_op_prec(i32 %38)     ; call get_op_prec(op)
  %40= icmp sge i32 %37, %39     ; stack_size(ops) && get_op_prec(stack_peek(ops))>=get_op_prec(op)
  br i1 %40, label %41, label %53     

41:     ; while Stmt
  %42= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0     
  %43 = call i32 @stack_pop(i32* %42)     ; call stack_pop(ops)
  store i32 %43, i32* %5     ; cur_op= = call i32 @stack_pop(i32* )
  %44= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  %45 = call i32 @stack_pop(i32* %44)     ; call stack_pop(oprs)
  store i32 %45, i32* %4     ; rhs= = call i32 @stack_pop(i32* )
  %46= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  %47 = call i32 @stack_pop(i32* %46)     ; call stack_pop(oprs)
  store i32 %47, i32* %3     ; lhs= = call i32 @stack_pop(i32* )
  %48= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  %49 = load i32, i32* %5     
  %50 = load i32, i32* %3     
  %51 = load i32, i32* %4     
  %52 = call i32 @eval_op(i32 %49,i32 %50,i32 %51)     ; call eval_op(cur_op,lhs,rhs)
  call void @stack_push(i32* %48,i32 %52)     ; call stack_push(oprs,eval_op(cur_op,lhs,rhs))
  br label %30     

53:     ; exit while
  %54= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0     
  %55 = load i32, i32* %6     
  call void @stack_push(i32* %54,i32 %55)     ; call stack_push(ops,op)
  %56 = load i32, i32* @cur_token     
  %57= icmp ne i32 %56, 0     ; cur_token!=TOKEN_NUM
  br i1 %57, label %58, label %60     ; judge cur_token!=TOKEN_NUM

58:     ; if Stmt
  %59 = call i32 @panic()     ; call panic()
  ret i32 %59     

60:     
  %61= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  %62 = load i32, i32* @num     
  call void @stack_push(i32* %61,i32 %62)     ; call stack_push(oprs,num)
  %63 = call i32 @next_token()     ; call next_token()
  br label %19     

64:     ; exit while
  %65 = call i32 @next_token()     ; call next_token()
  br label %66     

66:     ; judge stack_size(ops)
  %67= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0     
  %68 = call i32 @stack_size(i32* %67)     ; call stack_size(ops)
  %69= icmp ne i32 %68, 0     
  br i1 %69, label %70, label %82     

70:     ; while Stmt
  %71= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0     
  %72 = call i32 @stack_pop(i32* %71)     ; call stack_pop(ops)
  store i32 %72, i32* %2     ; cur_op= = call i32 @stack_pop(i32* )
  %73= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  %74 = call i32 @stack_pop(i32* %73)     ; call stack_pop(oprs)
  store i32 %74, i32* %1     ; rhs= = call i32 @stack_pop(i32* )
  %75= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  %76 = call i32 @stack_pop(i32* %75)     ; call stack_pop(oprs)
  store i32 %76, i32* %0     ; lhs= = call i32 @stack_pop(i32* )
  %77= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  %78 = load i32, i32* %2     
  %79 = load i32, i32* %0     
  %80 = load i32, i32* %1     
  %81 = call i32 @eval_op(i32 %78,i32 %79,i32 %80)     ; call eval_op(cur_op,lhs,rhs)
  call void @stack_push(i32* %77,i32 %81)     ; call stack_push(oprs,eval_op(cur_op,lhs,rhs))
  br label %66     

82:     ; exit while
  %83= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0     
  %84 = call i32 @stack_peek(i32* %83)     ; call stack_peek(oprs)
  ret i32 %84     
}

define dso_local i32 @main(){
entry:     
  %0 = alloca i32     ; i32 count=getint()
  %1 = call i32 @getint()     ; call getint()
  store i32 %1, i32* %0     ; count= = call i32 @getint()
  %2 = call i32 @getch()     ; call getch()
  %3 = call i32 @next_token()     ; call next_token()
  br label %4     

4:     ; judge count
  %5 = load i32, i32* %0     
  %6= icmp ne i32 %5, 0     
  br i1 %6, label %7, label %11     

7:     ; while Stmt
  %8 = call i32 @eval()     ; call eval()
  call void @putint(i32 %8)     ; call putint(eval())
  call void @putch(i32 10)     ; call putch(10)
  %9 = load i32, i32* %0     
  %10 = sub i32 %9, 1     ; count-1
  store i32 %10, i32* %0     ; count=count-1
  br label %4     

11:     ; exit while
  ret i32 0     
}

