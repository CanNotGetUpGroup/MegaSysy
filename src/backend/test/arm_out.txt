	.data
	.global	last_char
	.align	2
	.type	last_char, %object
	.size	last_char, 4
last_char:
	.word	32
	.global	num
	.align	2
	.type	num, %object
	.size	num, 4
num:
	.word	0
	.global	other
	.align	2
	.type	other, %object
	.size	other, 4
other:
	.word	0
	.global	cur_token
	.align	2
	.type	cur_token, %object
	.size	cur_token, 4
cur_token:
	.word	0
	.text
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	next_char
	.type	next_char, %function
next_char:
.next_char1:
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #16
	@ %0 = call i32 @getch()
	BLX	getch
	mov	r4, r0
	STR r4, [ r11 , #-8 ]
	@ store i32 %0, i32* @last_char
	movw	r4, #:lower16:last_char
	movt	r4, #:upper16:last_char

	STR r4, [ r11 , #-12 ]
	LDR r5, [ r11 , #-8 ]
	LDR r7, [ r11 , #-12 ]
	STR r5, [ r7 ]
	@ %1 = load i32, i32* @last_char
	movw	r4, #:lower16:last_char
	movt	r4, #:upper16:last_char

	STR r4, [ r11 , #-16 ]
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-20 ]
	@ ret i32 %1
	LDR r6, [ r11 , #-20 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	Pop { PC }

	.size	next_char, .-next_char
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	is_space
	.type	is_space, %function
is_space:
.is_space2:
	Push { LR }
	Push { LR }
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #16
	mov	r4, r0
	STR r4, [ r11 , #-12 ]
	@ %1 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , #-16 ]
	@ store i32 %0, i32* %1
	LDR r5, [ r11 , #-12 ]
	LDR r7, [ r11 , #-16 ]
	STR r5, [ r7 ]
	@ %2 = load i32, i32* %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-20 ]
	@ %3= icmp eq i32 %2, 32
	@ br i1 %3, label %7, label %4
	LDR r5, [ r11 , #-20 ]
	cmp r5 , #32
	BEQ	.is_space4
	B	.is_space3

.is_space3:
	@ %5 = load i32, i32* %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-24 ]
	@ %6= icmp eq i32 %5, 10
	@ br i1 %6, label %7, label %8
	LDR r5, [ r11 , #-24 ]
	cmp r5 , #10
	BEQ	.is_space4
	B	.is_space5

.is_space4:
	@ ret i32 1
	mov	r0, #1
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.is_space5:
	@ ret i32 0
	mov	r0, #0
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.is_space6:
	@ ret i32 0
	mov	r0, #0
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

	.size	is_space, .-is_space
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	is_num
	.type	is_num, %function
is_num:
.is_num7:
	Push { LR }
	Push { LR }
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #16
	mov	r4, r0
	STR r4, [ r11 , #-12 ]
	@ %1 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , #-16 ]
	@ store i32 %0, i32* %1
	LDR r5, [ r11 , #-12 ]
	LDR r7, [ r11 , #-16 ]
	STR r5, [ r7 ]
	@ %2 = load i32, i32* %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-20 ]
	@ %3= icmp sge i32 %2, 48
	@ br i1 %3, label %4, label %8
	LDR r5, [ r11 , #-20 ]
	cmp r5 , #48
	BGE	.is_num8
	B	.is_num10

.is_num8:
	@ %5 = load i32, i32* %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-24 ]
	@ %6= icmp sle i32 %5, 57
	@ br i1 %6, label %7, label %8
	LDR r5, [ r11 , #-24 ]
	cmp r5 , #57
	BLE	.is_num9
	B	.is_num10

.is_num9:
	@ ret i32 1
	mov	r0, #1
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.is_num10:
	@ ret i32 0
	mov	r0, #0
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.is_num11:
	@ ret i32 0
	mov	r0, #0
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

	.size	is_num, .-is_num
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	next_token
	.type	next_token, %function
next_token:
.next_token12:
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #128
	@ br label %0
	B	.next_token13

.next_token13:
	@ %1 = load i32, i32* @last_char
	movw	r4, #:lower16:last_char
	movt	r4, #:upper16:last_char

	STR r4, [ r11 , #-8 ]
	LDR r7, [ r11 , #-8 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-12 ]
	@ %2 = call i32 @is_space(i32 %1)
	LDR r6, [ r11 , #-12 ]
	mov	r0, r6
	BLX	is_space
	mov	r4, r0
	STR r4, [ r11 , #-16 ]
	@ %3= icmp ne i32 %2, 0
	@ br i1 %3, label %4, label %6
	LDR r5, [ r11 , #-16 ]
	cmp r5 , #0
	BNE	.next_token14
	B	.next_token15

.next_token14:
	@ %5 = call i32 @next_char()
	BLX	next_char
	mov	r4, r0
	STR r4, [ r11 , #-20 ]
	@ br label %0
	B	.next_token13

.next_token15:
	@ %7 = load i32, i32* @last_char
	movw	r4, #:lower16:last_char
	movt	r4, #:upper16:last_char

	STR r4, [ r11 , #-24 ]
	LDR r7, [ r11 , #-24 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-28 ]
	@ %8 = call i32 @is_num(i32 %7)
	LDR r6, [ r11 , #-28 ]
	mov	r0, r6
	BLX	is_num
	mov	r4, r0
	STR r4, [ r11 , #-32 ]
	@ %9= icmp ne i32 %8, 0
	@ br i1 %9, label %10, label %24
	LDR r5, [ r11 , #-32 ]
	cmp r5 , #0
	BNE	.next_token16
	B	.next_token20

.next_token16:
	@ %11 = load i32, i32* @last_char
	movw	r4, #:lower16:last_char
	movt	r4, #:upper16:last_char

	STR r4, [ r11 , #-36 ]
	LDR r7, [ r11 , #-36 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-40 ]
	@ %12 = sub i32 %11, 48
	LDR r5, [ r11 , #-40 ]
	SUB	r4, r5, #48
	STR r4, [ r11 , #-44 ]
	@ store i32 %12, i32* @num
	movw	r4, #:lower16:num
	movt	r4, #:upper16:num

	STR r4, [ r11 , #-48 ]
	LDR r5, [ r11 , #-44 ]
	LDR r7, [ r11 , #-48 ]
	STR r5, [ r7 ]
	@ br label %13
	B	.next_token17

.next_token17:
	@ %14 = call i32 @next_char()
	BLX	next_char
	mov	r4, r0
	STR r4, [ r11 , #-52 ]
	@ %15 = call i32 @is_num(i32 %14)
	LDR r6, [ r11 , #-52 ]
	mov	r0, r6
	BLX	is_num
	mov	r4, r0
	STR r4, [ r11 , #-56 ]
	@ %16= icmp ne i32 %15, 0
	@ br i1 %16, label %17, label %23
	LDR r5, [ r11 , #-56 ]
	cmp r5 , #0
	BNE	.next_token18
	B	.next_token19

.next_token18:
	@ %18 = load i32, i32* @num
	movw	r4, #:lower16:num
	movt	r4, #:upper16:num

	STR r4, [ r11 , #-60 ]
	LDR r7, [ r11 , #-60 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-64 ]
	@ %19 = mul i32 %18, 10
	mov	r4, #10
	STR r4, [ r11 , #-68 ]
	LDR r5, [ r11 , #-64 ]
	LDR r6, [ r11 , #-68 ]
	MUL	r4, r5, r6
	STR r4, [ r11 , #-72 ]
	@ %20 = load i32, i32* @last_char
	movw	r4, #:lower16:last_char
	movt	r4, #:upper16:last_char

	STR r4, [ r11 , #-76 ]
	LDR r7, [ r11 , #-76 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-80 ]
	@ %21 = add i32 %19, %20
	LDR r5, [ r11 , #-72 ]
	LDR r6, [ r11 , #-80 ]
	ADD	r4, r5, r6
	STR r4, [ r11 , #-84 ]
	@ %22 = sub i32 %21, 48
	LDR r5, [ r11 , #-84 ]
	SUB	r4, r5, #48
	STR r4, [ r11 , #-88 ]
	@ store i32 %22, i32* @num
	movw	r4, #:lower16:num
	movt	r4, #:upper16:num

	STR r4, [ r11 , #-92 ]
	LDR r5, [ r11 , #-88 ]
	LDR r7, [ r11 , #-92 ]
	STR r5, [ r7 ]
	@ br label %13
	B	.next_token17

.next_token19:
	@ store i32 0, i32* @cur_token
	mov	r4, #0
	STR r4, [ r11 , #-96 ]
	movw	r4, #:lower16:cur_token
	movt	r4, #:upper16:cur_token

	STR r4, [ r11 , #-100 ]
	LDR r5, [ r11 , #-96 ]
	LDR r7, [ r11 , #-100 ]
	STR r5, [ r7 ]
	@ br label %27
	B	.next_token21

.next_token20:
	@ %25 = load i32, i32* @last_char
	movw	r4, #:lower16:last_char
	movt	r4, #:upper16:last_char

	STR r4, [ r11 , #-104 ]
	LDR r7, [ r11 , #-104 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-108 ]
	@ store i32 %25, i32* @other
	movw	r4, #:lower16:other
	movt	r4, #:upper16:other

	STR r4, [ r11 , #-112 ]
	LDR r5, [ r11 , #-108 ]
	LDR r7, [ r11 , #-112 ]
	STR r5, [ r7 ]
	@ %26 = call i32 @next_char()
	BLX	next_char
	mov	r4, r0
	STR r4, [ r11 , #-116 ]
	@ store i32 1, i32* @cur_token
	mov	r4, #1
	STR r4, [ r11 , #-120 ]
	movw	r4, #:lower16:cur_token
	movt	r4, #:upper16:cur_token

	STR r4, [ r11 , #-124 ]
	LDR r5, [ r11 , #-120 ]
	LDR r7, [ r11 , #-124 ]
	STR r5, [ r7 ]
	@ br label %27
	B	.next_token21

.next_token21:
	@ %28 = load i32, i32* @cur_token
	movw	r4, #:lower16:cur_token
	movt	r4, #:upper16:cur_token

	STR r4, [ r11 , #-128 ]
	LDR r7, [ r11 , #-128 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-132 ]
	@ ret i32 %28
	LDR r6, [ r11 , #-132 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	Pop { PC }

	.size	next_token, .-next_token
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	panic
	.type	panic, %function
panic:
.panic22:
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #28
	@ call void @putch(i32 112)
	mov	r0, #112
	BLX	putch
	mov	r4, r0
	STR r4, [ r11 , #-8 ]
	@ call void @putch(i32 97)
	mov	r0, #97
	BLX	putch
	mov	r4, r0
	STR r4, [ r11 , #-12 ]
	@ call void @putch(i32 110)
	mov	r0, #110
	BLX	putch
	mov	r4, r0
	STR r4, [ r11 , #-16 ]
	@ call void @putch(i32 105)
	mov	r0, #105
	BLX	putch
	mov	r4, r0
	STR r4, [ r11 , #-20 ]
	@ call void @putch(i32 99)
	mov	r0, #99
	BLX	putch
	mov	r4, r0
	STR r4, [ r11 , #-24 ]
	@ call void @putch(i32 33)
	mov	r0, #33
	BLX	putch
	mov	r4, r0
	STR r4, [ r11 , #-28 ]
	@ call void @putch(i32 10)
	mov	r0, #10
	BLX	putch
	mov	r4, r0
	STR r4, [ r11 , #-32 ]
	@ ret i32 -1
	mov	r0, #-1
	SUB	SP, r11, #4
	Pop { r11 }
	Pop { PC }

	.size	panic, .-panic
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	get_op_prec
	.type	get_op_prec, %function
get_op_prec:
.get_op_prec23:
	Push { LR }
	Push { LR }
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #28
	mov	r4, r0
	STR r4, [ r11 , #-12 ]
	@ %1 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , #-16 ]
	@ store i32 %0, i32* %1
	LDR r5, [ r11 , #-12 ]
	LDR r7, [ r11 , #-16 ]
	STR r5, [ r7 ]
	@ %2 = load i32, i32* %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-20 ]
	@ %3= icmp eq i32 %2, 43
	@ br i1 %3, label %7, label %4
	LDR r5, [ r11 , #-20 ]
	cmp r5 , #43
	BEQ	.get_op_prec25
	B	.get_op_prec24

.get_op_prec24:
	@ %5 = load i32, i32* %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-24 ]
	@ %6= icmp eq i32 %5, 45
	@ br i1 %6, label %7, label %8
	LDR r5, [ r11 , #-24 ]
	cmp r5 , #45
	BEQ	.get_op_prec25
	B	.get_op_prec26

.get_op_prec25:
	@ ret i32 10
	mov	r0, #10
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.get_op_prec26:
	@ %9 = load i32, i32* %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-28 ]
	@ %10= icmp eq i32 %9, 42
	@ br i1 %10, label %17, label %11
	LDR r5, [ r11 , #-28 ]
	cmp r5 , #42
	BEQ	.get_op_prec29
	B	.get_op_prec27

.get_op_prec27:
	@ %12 = load i32, i32* %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-32 ]
	@ %13= icmp eq i32 %12, 47
	@ br i1 %13, label %17, label %14
	LDR r5, [ r11 , #-32 ]
	cmp r5 , #47
	BEQ	.get_op_prec29
	B	.get_op_prec28

.get_op_prec28:
	@ %15 = load i32, i32* %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-36 ]
	@ %16= icmp eq i32 %15, 37
	@ br i1 %16, label %17, label %18
	LDR r5, [ r11 , #-36 ]
	cmp r5 , #37
	BEQ	.get_op_prec29
	B	.get_op_prec30

.get_op_prec29:
	@ ret i32 20
	mov	r0, #20
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.get_op_prec30:
	@ ret i32 0
	mov	r0, #0
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

	.size	get_op_prec, .-get_op_prec
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	stack_push
	.type	stack_push, %function
stack_push:
.stack_push31:
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #60
	mov	r4, r0
	STR r4, [ r11 , #-16 ]
	mov	r4, r1
	STR r4, [ r11 , #-20 ]
	@ %2 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , #-24 ]
	@ %3 = alloca i32*
	SUB	SP, SP, #4
	SUB	r4, r11, #12
	STR r4, [ r11 , #-28 ]
	@ store i32* %0, i32** %3
	LDR r5, [ r11 , #-16 ]
	LDR r7, [ r11 , #-28 ]
	STR r5, [ r7 ]
	@ store i32 %1, i32* %2
	LDR r5, [ r11 , #-20 ]
	LDR r7, [ r11 , #-24 ]
	STR r5, [ r7 ]
	@ %4 = load i32*, i32** %3
	LDR r7, [ r11 , #-28 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-32 ]
	@ %5= getelementptr i32,i32* %4 , i32 0
	@ %6 = load i32*, i32** %3
	LDR r7, [ r11 , #-28 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-36 ]
	@ %7= getelementptr i32,i32* %6 , i32 0
	@ %8 = load i32, i32* %7
	LDR r7, [ r11 , #-36 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-40 ]
	@ %9 = add i32 %8, 1
	LDR r5, [ r11 , #-40 ]
	ADD	r4, r5, #1
	STR r4, [ r11 , #-44 ]
	@ store i32 %9, i32* %5
	LDR r5, [ r11 , #-44 ]
	LDR r7, [ r11 , #-32 ]
	STR r5, [ r7 ]
	@ %10 = load i32*, i32** %3
	LDR r7, [ r11 , #-28 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-48 ]
	@ %11 = load i32*, i32** %3
	LDR r7, [ r11 , #-28 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-52 ]
	@ %12= getelementptr i32,i32* %11 , i32 0
	@ %13 = load i32, i32* %12
	LDR r7, [ r11 , #-52 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-56 ]
	@ %14= getelementptr i32,i32* %10 , i32 %13
	mov	r4, 4
	STR r4, [ r11 , #-60 ]
	LDR r5, [ r11 , #-56 ]
	LDR r6, [ r11 , #-60 ]
	MUL	r4, r5, r6
	STR r4, [ r11 , #-64 ]
	LDR r5, [ r11 , #-48 ]
	LDR r6, [ r11 , #-64 ]
	ADD	r4, r5, r6
	STR r4, [ r11 , #-68 ]
	@ %15 = load i32, i32* %2
	LDR r7, [ r11 , #-24 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-72 ]
	@ store i32 %15, i32* %14
	LDR r5, [ r11 , #-72 ]
	LDR r7, [ r11 , #-68 ]
	STR r5, [ r7 ]
	@ ret void
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

	.size	stack_push, .-stack_push
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	stack_pop
	.type	stack_pop, %function
stack_pop:
.stack_pop32:
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #60
	mov	r4, r0
	STR r4, [ r11 , #-16 ]
	@ %1 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , #-20 ]
	@ %2 = alloca i32*
	SUB	SP, SP, #4
	SUB	r4, r11, #12
	STR r4, [ r11 , #-24 ]
	@ store i32* %0, i32** %2
	LDR r5, [ r11 , #-16 ]
	LDR r7, [ r11 , #-24 ]
	STR r5, [ r7 ]
	@ %3 = load i32*, i32** %2
	LDR r7, [ r11 , #-24 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-28 ]
	@ %4 = load i32*, i32** %2
	LDR r7, [ r11 , #-24 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-32 ]
	@ %5= getelementptr i32,i32* %4 , i32 0
	@ %6 = load i32, i32* %5
	LDR r7, [ r11 , #-32 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-36 ]
	@ %7= getelementptr i32,i32* %3 , i32 %6
	mov	r4, 4
	STR r4, [ r11 , #-40 ]
	LDR r5, [ r11 , #-36 ]
	LDR r6, [ r11 , #-40 ]
	MUL	r4, r5, r6
	STR r4, [ r11 , #-44 ]
	LDR r5, [ r11 , #-28 ]
	LDR r6, [ r11 , #-44 ]
	ADD	r4, r5, r6
	STR r4, [ r11 , #-48 ]
	@ %8 = load i32, i32* %7
	LDR r7, [ r11 , #-48 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-52 ]
	@ store i32 %8, i32* %1
	LDR r5, [ r11 , #-52 ]
	LDR r7, [ r11 , #-20 ]
	STR r5, [ r7 ]
	@ %9 = load i32*, i32** %2
	LDR r7, [ r11 , #-24 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-56 ]
	@ %10= getelementptr i32,i32* %9 , i32 0
	@ %11 = load i32*, i32** %2
	LDR r7, [ r11 , #-24 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-60 ]
	@ %12= getelementptr i32,i32* %11 , i32 0
	@ %13 = load i32, i32* %12
	LDR r7, [ r11 , #-60 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-64 ]
	@ %14 = sub i32 %13, 1
	LDR r5, [ r11 , #-64 ]
	SUB	r4, r5, #1
	STR r4, [ r11 , #-68 ]
	@ store i32 %14, i32* %10
	LDR r5, [ r11 , #-68 ]
	LDR r7, [ r11 , #-56 ]
	STR r5, [ r7 ]
	@ %15 = load i32, i32* %1
	LDR r7, [ r11 , #-20 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-72 ]
	@ ret i32 %15
	LDR r6, [ r11 , #-72 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

	.size	stack_pop, .-stack_pop
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	stack_peek
	.type	stack_peek, %function
stack_peek:
.stack_peek33:
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #36
	mov	r4, r0
	STR r4, [ r11 , #-12 ]
	@ %1 = alloca i32*
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , #-16 ]
	@ store i32* %0, i32** %1
	LDR r5, [ r11 , #-12 ]
	LDR r7, [ r11 , #-16 ]
	STR r5, [ r7 ]
	@ %2 = load i32*, i32** %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-20 ]
	@ %3 = load i32*, i32** %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-24 ]
	@ %4= getelementptr i32,i32* %3 , i32 0
	@ %5 = load i32, i32* %4
	LDR r7, [ r11 , #-24 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-28 ]
	@ %6= getelementptr i32,i32* %2 , i32 %5
	mov	r4, 4
	STR r4, [ r11 , #-32 ]
	LDR r5, [ r11 , #-28 ]
	LDR r6, [ r11 , #-32 ]
	MUL	r4, r5, r6
	STR r4, [ r11 , #-36 ]
	LDR r5, [ r11 , #-20 ]
	LDR r6, [ r11 , #-36 ]
	ADD	r4, r5, r6
	STR r4, [ r11 , #-40 ]
	@ %7 = load i32, i32* %6
	LDR r7, [ r11 , #-40 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-44 ]
	@ ret i32 %7
	LDR r6, [ r11 , #-44 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

	.size	stack_peek, .-stack_peek
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	stack_size
	.type	stack_size, %function
stack_size:
.stack_size34:
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #16
	mov	r4, r0
	STR r4, [ r11 , #-12 ]
	@ %1 = alloca i32*
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , #-16 ]
	@ store i32* %0, i32** %1
	LDR r5, [ r11 , #-12 ]
	LDR r7, [ r11 , #-16 ]
	STR r5, [ r7 ]
	@ %2 = load i32*, i32** %1
	LDR r7, [ r11 , #-16 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-20 ]
	@ %3= getelementptr i32,i32* %2 , i32 0
	@ %4 = load i32, i32* %3
	LDR r7, [ r11 , #-20 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-24 ]
	@ ret i32 %4
	LDR r6, [ r11 , #-24 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

	.size	stack_size, .-stack_size
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	eval_op
	.type	eval_op, %function
eval_op:
.eval_op35:
	Push { LR }
	Push { LR }
	Push { LR }
	Push { LR }
	Push { LR }
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #104
	mov	r4, r0
	STR r4, [ r11 , #-20 ]
	mov	r4, r1
	STR r4, [ r11 , #-24 ]
	mov	r4, r2
	STR r4, [ r11 , #-28 ]
	@ %3 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , #-32 ]
	@ %4 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #12
	STR r4, [ r11 , #-36 ]
	@ %5 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #16
	STR r4, [ r11 , #-40 ]
	@ store i32 %0, i32* %5
	LDR r5, [ r11 , #-20 ]
	LDR r7, [ r11 , #-40 ]
	STR r5, [ r7 ]
	@ store i32 %1, i32* %4
	LDR r5, [ r11 , #-24 ]
	LDR r7, [ r11 , #-36 ]
	STR r5, [ r7 ]
	@ store i32 %2, i32* %3
	LDR r5, [ r11 , #-28 ]
	LDR r7, [ r11 , #-32 ]
	STR r5, [ r7 ]
	@ %6 = load i32, i32* %5
	LDR r7, [ r11 , #-40 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-44 ]
	@ %7= icmp eq i32 %6, 43
	@ br i1 %7, label %8, label %12
	LDR r5, [ r11 , #-44 ]
	cmp r5 , #43
	BEQ	.eval_op36
	B	.eval_op37

.eval_op36:
	@ %9 = load i32, i32* %4
	LDR r7, [ r11 , #-36 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-48 ]
	@ %10 = load i32, i32* %3
	LDR r7, [ r11 , #-32 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-52 ]
	@ %11 = add i32 %9, %10
	LDR r5, [ r11 , #-48 ]
	LDR r6, [ r11 , #-52 ]
	ADD	r4, r5, r6
	STR r4, [ r11 , #-56 ]
	@ ret i32 %11
	LDR r6, [ r11 , #-56 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.eval_op37:
	@ %13 = load i32, i32* %5
	LDR r7, [ r11 , #-40 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-60 ]
	@ %14= icmp eq i32 %13, 45
	@ br i1 %14, label %15, label %19
	LDR r5, [ r11 , #-60 ]
	cmp r5 , #45
	BEQ	.eval_op38
	B	.eval_op39

.eval_op38:
	@ %16 = load i32, i32* %4
	LDR r7, [ r11 , #-36 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-64 ]
	@ %17 = load i32, i32* %3
	LDR r7, [ r11 , #-32 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-68 ]
	@ %18 = sub i32 %16, %17
	LDR r5, [ r11 , #-64 ]
	LDR r6, [ r11 , #-68 ]
	SUB	r4, r5, r6
	STR r4, [ r11 , #-72 ]
	@ ret i32 %18
	LDR r6, [ r11 , #-72 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.eval_op39:
	@ %20 = load i32, i32* %5
	LDR r7, [ r11 , #-40 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-76 ]
	@ %21= icmp eq i32 %20, 42
	@ br i1 %21, label %22, label %26
	LDR r5, [ r11 , #-76 ]
	cmp r5 , #42
	BEQ	.eval_op40
	B	.eval_op41

.eval_op40:
	@ %23 = load i32, i32* %4
	LDR r7, [ r11 , #-36 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-80 ]
	@ %24 = load i32, i32* %3
	LDR r7, [ r11 , #-32 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-84 ]
	@ %25 = mul i32 %23, %24
	LDR r5, [ r11 , #-80 ]
	LDR r6, [ r11 , #-84 ]
	MUL	r4, r5, r6
	STR r4, [ r11 , #-88 ]
	@ ret i32 %25
	LDR r6, [ r11 , #-88 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.eval_op41:
	@ %27 = load i32, i32* %5
	LDR r7, [ r11 , #-40 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-92 ]
	@ %28= icmp eq i32 %27, 47
	@ br i1 %28, label %29, label %33
	LDR r5, [ r11 , #-92 ]
	cmp r5 , #47
	BEQ	.eval_op42
	B	.eval_op43

.eval_op42:
	@ %30 = load i32, i32* %4
	LDR r7, [ r11 , #-36 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-96 ]
	@ %31 = load i32, i32* %3
	LDR r7, [ r11 , #-32 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-100 ]
	@ %32 = sdiv i32 %30, %31
	LDR r5, [ r11 , #-96 ]
	LDR r6, [ r11 , #-100 ]
	SDIV	r4, r5, r6
	STR r4, [ r11 , #-104 ]
	@ ret i32 %32
	LDR r6, [ r11 , #-104 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	BX	LR

.eval_op43:
	@ %34 = load i32, i32* %5
	LDR r7, [ r11 , #-40 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-108 ]
	@ %35= icmp eq i32 %34, 37
	@ br i1 %35, label %36, label %40
	LDR r5, [ r11 , #-108 ]
	cmp r5 , #37
	BEQ	.eval_op44
	B	.eval_op45

.eval_op44:
	@ %37 = load i32, i32* %4
	LDR r7, [ r11 , #-36 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-112 ]
	@ %38 = load i32, i32* %3
	LDR r7, [ r11 , #-32 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-116 ]
	@ %39 = srem i32 %37, %38
	LDR r6, [ r11 , #-112 ]
	mov	r0, r6
	LDR r6, [ r11 , #-116 ]
	mov	r1, r6
	BLX	__aeabi_idivmod
	mov	r4, r1
	STR r4, [ r11 , #-120 ]
	@ ret i32 %39
	LDR r6, [ r11 , #-120 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	Pop { PC }

.eval_op45:
	@ ret i32 0
	mov	r0, #0
	SUB	SP, r11, #4
	Pop { r11 }
	Pop { PC }

	.size	eval_op, .-eval_op
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	eval
	.type	eval, %function
eval:
.eval46:
	Push { LR }
	Push { LR }
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #232
	@ %7 = alloca [256 x i32]
	SUB	SP, SP, #1024
	SUB	r4, r11, #1056
	STR r4, [ r11 , -2084 ]
	@ %8 = alloca [256 x i32]
	SUB	SP, SP, #1024
	SUB	r4, r11, #2080
	STR r4, [ r11 , -2088 ]
	@ %9= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ call void @memset(i32* %9,i32 0,i32 1024)
	mov	r2, #1024
	mov	r1, #0
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	memset
	mov	r4, r0
	STR r4, [ r11 , -2092 ]
	@ %10= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0
	@ call void @memset(i32* %10,i32 0,i32 1024)
	mov	r2, #1024
	mov	r1, #0
	LDR r6, [ r11 , -2084 ]
	mov	r0, r6
	BLX	memset
	mov	r4, r0
	STR r4, [ r11 , #-2096 ]
	@ %11 = load i32, i32* @cur_token
	movw	r4, #:lower16:cur_token
	movt	r4, #:upper16:cur_token

	STR r4, [ r11 , -2100 ]
	LDR r7, [ r11 , -2100 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2104 ]
	@ %12= icmp ne i32 %11, 0
	@ br i1 %12, label %13, label %15
	LDR r5, [ r11 , -2104 ]
	cmp r5 , #0
	BNE	.eval47
	B	.eval48

.eval47:
	@ %14 = call i32 @panic()
	BLX	panic
	mov	r4, r0
	STR r4, [ r11 , -2108 ]
	@ ret i32 %14
	LDR r6, [ r11 , -2108 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	Pop { PC }

.eval48:
	@ %16= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ %17 = load i32, i32* @num
	movw	r4, #:lower16:num
	movt	r4, #:upper16:num

	STR r4, [ r11 , #-2112 ]
	LDR r7, [ r11 , #-2112 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2116 ]
	@ call void @stack_push(i32* %16,i32 %17)
	LDR r6, [ r11 , -2116 ]
	mov	r1, r6
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	stack_push
	mov	r4, r0
	STR r4, [ r11 , -2120 ]
	@ %18 = call i32 @next_token()
	BLX	next_token
	mov	r4, r0
	STR r4, [ r11 , -2124 ]
	@ br label %19
	B	.eval49

.eval49:
	@ %20 = load i32, i32* @cur_token
	movw	r4, #:lower16:cur_token
	movt	r4, #:upper16:cur_token

	STR r4, [ r11 , #-2128 ]
	LDR r7, [ r11 , #-2128 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2132 ]
	@ %21= icmp eq i32 %20, 1
	@ br i1 %21, label %22, label %64
	LDR r5, [ r11 , -2132 ]
	cmp r5 , #1
	BEQ	.eval50
	B	.eval59

.eval50:
	@ %6 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #32
	STR r4, [ r11 , -2136 ]
	@ %23 = load i32, i32* @other
	movw	r4, #:lower16:other
	movt	r4, #:upper16:other

	STR r4, [ r11 , -2140 ]
	LDR r7, [ r11 , -2140 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-2144 ]
	@ store i32 %23, i32* %6
	LDR r5, [ r11 , #-2144 ]
	LDR r7, [ r11 , -2136 ]
	STR r5, [ r7 ]
	@ %24 = load i32, i32* %6
	LDR r7, [ r11 , -2136 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2148 ]
	@ %25 = call i32 @get_op_prec(i32 %24)
	LDR r6, [ r11 , -2148 ]
	mov	r0, r6
	BLX	get_op_prec
	mov	r4, r0
	STR r4, [ r11 , -2152 ]
	@ %26= icmp eq i32 %25, 0
	@ br i1 %26, label %27, label %28
	LDR r5, [ r11 , -2152 ]
	cmp r5 , #0
	BEQ	.eval51
	B	.eval52

.eval51:
	@ br label %64
	B	.eval59

.eval52:
	@ %29 = call i32 @next_token()
	BLX	next_token
	mov	r4, r0
	STR r4, [ r11 , -2156 ]
	@ br label %30
	B	.eval53

.eval53:
	@ %31= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0
	@ %32 = call i32 @stack_size(i32* %31)
	LDR r6, [ r11 , -2084 ]
	mov	r0, r6
	BLX	stack_size
	mov	r4, r0
	STR r4, [ r11 , #-2160 ]
	@ %33= icmp ne i32 %32, 0
	@ br i1 %33, label %34, label %53
	LDR r5, [ r11 , #-2160 ]
	cmp r5 , #0
	BNE	.eval54
	B	.eval56

.eval54:
	@ %35= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0
	@ %36 = call i32 @stack_peek(i32* %35)
	LDR r6, [ r11 , -2084 ]
	mov	r0, r6
	BLX	stack_peek
	mov	r4, r0
	STR r4, [ r11 , -2164 ]
	@ %37 = call i32 @get_op_prec(i32 %36)
	LDR r6, [ r11 , -2164 ]
	mov	r0, r6
	BLX	get_op_prec
	mov	r4, r0
	STR r4, [ r11 , -2168 ]
	@ %38 = load i32, i32* %6
	LDR r7, [ r11 , -2136 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2172 ]
	@ %39 = call i32 @get_op_prec(i32 %38)
	LDR r6, [ r11 , -2172 ]
	mov	r0, r6
	BLX	get_op_prec
	mov	r4, r0
	STR r4, [ r11 , #-2176 ]
	@ %40= icmp sge i32 %37, %39
	@ br i1 %40, label %41, label %53
	LDR r5, [ r11 , -2168 ]
	LDR r6, [ r11 , #-2176 ]
	cmp r5 , r6
	BGE	.eval55
	B	.eval56

.eval55:
	@ %3 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #20
	STR r4, [ r11 , -2180 ]
	@ %4 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #24
	STR r4, [ r11 , -2184 ]
	@ %5 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #28
	STR r4, [ r11 , -2188 ]
	@ %42= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0
	@ %43 = call i32 @stack_pop(i32* %42)
	LDR r6, [ r11 , -2084 ]
	mov	r0, r6
	BLX	stack_pop
	mov	r4, r0
	STR r4, [ r11 , #-2192 ]
	@ store i32 %43, i32* %5
	LDR r5, [ r11 , #-2192 ]
	LDR r7, [ r11 , -2188 ]
	STR r5, [ r7 ]
	@ %44= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ %45 = call i32 @stack_pop(i32* %44)
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	stack_pop
	mov	r4, r0
	STR r4, [ r11 , -2196 ]
	@ store i32 %45, i32* %4
	LDR r5, [ r11 , -2196 ]
	LDR r7, [ r11 , -2184 ]
	STR r5, [ r7 ]
	@ %46= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ %47 = call i32 @stack_pop(i32* %46)
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	stack_pop
	mov	r4, r0
	STR r4, [ r11 , -2200 ]
	@ store i32 %47, i32* %3
	LDR r5, [ r11 , -2200 ]
	LDR r7, [ r11 , -2180 ]
	STR r5, [ r7 ]
	@ %48= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ %49 = load i32, i32* %5
	LDR r7, [ r11 , -2188 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2204 ]
	@ %50 = load i32, i32* %3
	LDR r7, [ r11 , -2180 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-2208 ]
	@ %51 = load i32, i32* %4
	LDR r7, [ r11 , -2184 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2212 ]
	@ %52 = call i32 @eval_op(i32 %49,i32 %50,i32 %51)
	LDR r6, [ r11 , -2212 ]
	mov	r2, r6
	LDR r6, [ r11 , #-2208 ]
	mov	r1, r6
	LDR r6, [ r11 , -2204 ]
	mov	r0, r6
	BLX	eval_op
	mov	r4, r0
	STR r4, [ r11 , -2216 ]
	@ call void @stack_push(i32* %48,i32 %52)
	LDR r6, [ r11 , -2216 ]
	mov	r1, r6
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	stack_push
	mov	r4, r0
	STR r4, [ r11 , -2220 ]
	@ br label %30
	B	.eval53

.eval56:
	@ %54= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0
	@ %55 = load i32, i32* %6
	LDR r7, [ r11 , -2136 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-2224 ]
	@ call void @stack_push(i32* %54,i32 %55)
	LDR r6, [ r11 , #-2224 ]
	mov	r1, r6
	LDR r6, [ r11 , -2084 ]
	mov	r0, r6
	BLX	stack_push
	mov	r4, r0
	STR r4, [ r11 , -2228 ]
	@ %56 = load i32, i32* @cur_token
	movw	r4, #:lower16:cur_token
	movt	r4, #:upper16:cur_token

	STR r4, [ r11 , -2232 ]
	LDR r7, [ r11 , -2232 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2236 ]
	@ %57= icmp ne i32 %56, 0
	@ br i1 %57, label %58, label %60
	LDR r5, [ r11 , -2236 ]
	cmp r5 , #0
	BNE	.eval57
	B	.eval58

.eval57:
	@ %59 = call i32 @panic()
	BLX	panic
	mov	r4, r0
	STR r4, [ r11 , #-2240 ]
	@ ret i32 %59
	LDR r6, [ r11 , #-2240 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	Pop { PC }

.eval58:
	@ %61= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ %62 = load i32, i32* @num
	movw	r4, #:lower16:num
	movt	r4, #:upper16:num

	STR r4, [ r11 , -2244 ]
	LDR r7, [ r11 , -2244 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2248 ]
	@ call void @stack_push(i32* %61,i32 %62)
	LDR r6, [ r11 , -2248 ]
	mov	r1, r6
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	stack_push
	mov	r4, r0
	STR r4, [ r11 , -2252 ]
	@ %63 = call i32 @next_token()
	BLX	next_token
	mov	r4, r0
	STR r4, [ r11 , #-2256 ]
	@ br label %19
	B	.eval49

.eval59:
	@ %65 = call i32 @next_token()
	BLX	next_token
	mov	r4, r0
	STR r4, [ r11 , -2260 ]
	@ br label %66
	B	.eval60

.eval60:
	@ %67= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0
	@ %68 = call i32 @stack_size(i32* %67)
	LDR r6, [ r11 , -2084 ]
	mov	r0, r6
	BLX	stack_size
	mov	r4, r0
	STR r4, [ r11 , -2264 ]
	@ %69= icmp ne i32 %68, 0
	@ br i1 %69, label %70, label %82
	LDR r5, [ r11 , -2264 ]
	cmp r5 , #0
	BNE	.eval61
	B	.eval62

.eval61:
	@ %0 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , -2268 ]
	@ %1 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #12
	STR r4, [ r11 , #-2272 ]
	@ %2 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #16
	STR r4, [ r11 , -2276 ]
	@ %71= getelementptr [256 x i32],[256 x i32]* %7 , i32 0, i32 0
	@ %72 = call i32 @stack_pop(i32* %71)
	LDR r6, [ r11 , -2084 ]
	mov	r0, r6
	BLX	stack_pop
	mov	r4, r0
	STR r4, [ r11 , -2280 ]
	@ store i32 %72, i32* %2
	LDR r5, [ r11 , -2280 ]
	LDR r7, [ r11 , -2276 ]
	STR r5, [ r7 ]
	@ %73= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ %74 = call i32 @stack_pop(i32* %73)
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	stack_pop
	mov	r4, r0
	STR r4, [ r11 , -2284 ]
	@ store i32 %74, i32* %1
	LDR r5, [ r11 , -2284 ]
	LDR r7, [ r11 , #-2272 ]
	STR r5, [ r7 ]
	@ %75= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ %76 = call i32 @stack_pop(i32* %75)
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	stack_pop
	mov	r4, r0
	STR r4, [ r11 , #-2288 ]
	@ store i32 %76, i32* %0
	LDR r5, [ r11 , #-2288 ]
	LDR r7, [ r11 , -2268 ]
	STR r5, [ r7 ]
	@ %77= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ %78 = load i32, i32* %2
	LDR r7, [ r11 , -2276 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2292 ]
	@ %79 = load i32, i32* %0
	LDR r7, [ r11 , -2268 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2296 ]
	@ %80 = load i32, i32* %1
	LDR r7, [ r11 , #-2272 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , -2300 ]
	@ %81 = call i32 @eval_op(i32 %78,i32 %79,i32 %80)
	LDR r6, [ r11 , -2300 ]
	mov	r2, r6
	LDR r6, [ r11 , -2296 ]
	mov	r1, r6
	LDR r6, [ r11 , -2292 ]
	mov	r0, r6
	BLX	eval_op
	mov	r4, r0
	STR r4, [ r11 , #-2304 ]
	@ call void @stack_push(i32* %77,i32 %81)
	LDR r6, [ r11 , #-2304 ]
	mov	r1, r6
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	stack_push
	mov	r4, r0
	STR r4, [ r11 , -2308 ]
	@ br label %66
	B	.eval60

.eval62:
	@ %83= getelementptr [256 x i32],[256 x i32]* %8 , i32 0, i32 0
	@ %84 = call i32 @stack_peek(i32* %83)
	LDR r6, [ r11 , -2088 ]
	mov	r0, r6
	BLX	stack_peek
	mov	r4, r0
	STR r4, [ r11 , -2312 ]
	@ ret i32 %84
	LDR r6, [ r11 , -2312 ]
	mov	r0, r6
	SUB	SP, r11, #4
	Pop { r11 }
	Pop { PC }

	.size	eval, .-eval
	.align	2
	.arch armv7ve
	.syntax unified
	.arm
	.fpu vfpv4
	.global	main
	.type	main, %function
main:
.main63:
	Push { LR }
	Push { r11 }
	ADD	r11, SP, #4
	SUB	SP, SP, #40
	@ %0 = alloca i32
	SUB	SP, SP, #4
	SUB	r4, r11, #8
	STR r4, [ r11 , #-12 ]
	@ %1 = call i32 @getint()
	BLX	getint
	mov	r4, r0
	STR r4, [ r11 , #-16 ]
	@ store i32 %1, i32* %0
	LDR r5, [ r11 , #-16 ]
	LDR r7, [ r11 , #-12 ]
	STR r5, [ r7 ]
	@ %2 = call i32 @getch()
	BLX	getch
	mov	r4, r0
	STR r4, [ r11 , #-20 ]
	@ %3 = call i32 @next_token()
	BLX	next_token
	mov	r4, r0
	STR r4, [ r11 , #-24 ]
	@ br label %4
	B	.main64

.main64:
	@ %5 = load i32, i32* %0
	LDR r7, [ r11 , #-12 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-28 ]
	@ %6= icmp ne i32 %5, 0
	@ br i1 %6, label %7, label %11
	LDR r5, [ r11 , #-28 ]
	cmp r5 , #0
	BNE	.main65
	B	.main66

.main65:
	@ %8 = call i32 @eval()
	BLX	eval
	mov	r4, r0
	STR r4, [ r11 , #-32 ]
	@ call void @putint(i32 %8)
	LDR r6, [ r11 , #-32 ]
	mov	r0, r6
	BLX	putint
	mov	r4, r0
	STR r4, [ r11 , #-36 ]
	@ call void @putch(i32 10)
	mov	r0, #10
	BLX	putch
	mov	r4, r0
	STR r4, [ r11 , #-40 ]
	@ %9 = load i32, i32* %0
	LDR r7, [ r11 , #-12 ]
	LDR r4, [ r7 ]
	STR r4, [ r11 , #-44 ]
	@ %10 = sub i32 %9, 1
	LDR r5, [ r11 , #-44 ]
	SUB	r4, r5, #1
	STR r4, [ r11 , #-48 ]
	@ store i32 %10, i32* %0
	LDR r5, [ r11 , #-48 ]
	LDR r7, [ r11 , #-12 ]
	STR r5, [ r7 ]
	@ br label %4
	B	.main64

.main66:
	@ ret i32 0
	mov	r0, #0
	SUB	SP, r11, #4
	Pop { r11 }
	Pop { PC }

	.size	main, .-main

